# Networks
Theory for lab 5 of Osasp
1 Рукопожатие в TCP.
Флаги SYN, ACK, FIN и другие в TCP.

In TCP connection, flags are used to indicate a particular state of connection or to provide some additional useful information like troubleshooting purposes or to handle a control of a particular connection. Most commonly used flags are **“SYN”, “ACK” and “FIN”**. Each flag corresponds to 1 bit information. 

**Types of Flags:**

- **Synchronization (SYN) –** It is used in first step of [**connection establishment**](https://www.geeksforgeeks.org/computer-network-tcp-connection-establishment/) phase or 3-way handshake process between the two hosts. Only the first packet from sender as well as receiver should have this flag set. This is used for synchronizing sequence number i.e. to tell the other end which sequence number they should accept.
- **Acknowledgement (ACK) –** It is used to acknowledge packets which are successful received by the host. The flag is set if the acknowledgement number field contains a valid acknowledgement number. In given below diagram, the receiver sends an ACK = 1 as well as SYN = 1 in the second step of connection establishment to tell sender that it received its initial packet.
- **Finish (FIN) –** It is used to request for [**connection termination**](https://www.geeksforgeeks.org/computer-network-tcp-connection-termination/) i.e. when there is no more data from the sender, it requests for connection termination. This is the last packet sent by sender. It frees the reserved resources and gracefully terminate the connection.
- **Reset (RST) –** It is used to terminate the connection if the RST sender feels something is wrong with the TCP connection or that the conversation should not exist. It can get send from receiver side when packet is send to particular host that was not expecting it.
- **Urgent (URG) –** It is used to indicate that the data contained in the packet should be prioritized and handled urgently by the receiver. This flag is used in combination with the Urgent Pointer field to identify the location of the urgent data in the packet.
- **Push (PSH) –** It is used to request immediate data delivery to the receiving host, without waiting for additional data to be buffered on the sender’s side. This flag is commonly used in applications such as real-time audio or video streaming.
- **Window (WND) –** It is used to communicate the size of the receive window to the sender. The window size is the amount of data that the receiving host is capable of accepting at any given time. The sender should limit the amount of data it sends based on the size of the window advertised by the receiver.
- **Checksum (CHK) –** It is used to verify the integrity of the TCP segment during transmission. The checksum is computed over the entire segment, including the header and data fields, and is recalculated at each hop along the network path.
- **Sequence Number (SEQ) –** It is a unique number assigned to each segment by the sender to identify the order in which packets should be received by the receiver. The sequence number is used in conjunction with the acknowledgement number to ensure reliable data transfer and to prevent duplicate packets.
- **Acknowledgement Number (ACK) –** It is used to acknowledge the receipt of a TCP segment and to communicate the next expected sequence number to the sender. The acknowledgement number field contains the sequence number of the next expected segment, rather than the number of the last received segment.

TCP is responsible for ensuring data is delivered correctly between computers on an internet network. The three-way handshake involves the following three steps: **synchronize (SYN), synchronize-acknowledge (SYN-ACK), and acknowledge (ACK)**.

2 

В TCP, когда вы пытаетесь отправить 8 единиц данных, а буфер способен вместить только 5, ваши данные будут обработаны следующим образом:

1. **Фрагментация данных**: TCP разделит 8 единиц данных на две части. Первая часть, соответствующая размеру буфера, в размере 5 единиц, будет отправлена первой.
2. **Ожидание подтверждения**: После отправки первых 5 единиц данных, TCP будет ожидать подтверждения получения этих данных от получателя.
3. **Отправка оставшихся данных**: Как только первые 5 единиц данных будут подтверждены, следующие 3 единицы данных будут отправлены.

Такой процесс гарантирует, что данные не теряются и оба буфера (отправителя и получателя) не переполняются. Это возможно благодаря механизмам TCP, таким как управление потоком и контроль за размером окна, которые регулируют, сколько данных может быть отправлено и когда.

3 Причины закрытия окна в TCP и механизмы его управления.

В TCP размер окна приема — это ключевой механизм управления потоком, который определяет объем данных, который отправитель может передать получателю без получения подтверждения. Однако бывают случаи, когда окно приема может быть временно "закрыто". Вот основные причины закрытия окна в TCP и механизмы его управления:

### Причины закрытия окна:

1. **Переполнение буфера приемника**: Если приложение на стороне получателя обрабатывает входящие данные медленнее, чем они поступают, буфер приемника может заполниться. В этом случае размер окна приема устанавливается в ноль, чтобы предотвратить дальнейшую отправку данных.
2. **Ограничения производительности приложения**: Приложение может установить размер окна приема на основе своей текущей способности обрабатывать данные. Например, приложение может сокращать окно приема, если оно занято другими задачами.

### Механизмы управления окном:

1. **Алгоритм скользящего окна**: TCP использует механизм скользящего окна, который позволяет динамически изменять размер окна в зависимости от сетевых условий и производительности получателя. Размер окна определяет объем данных, который можно отправить до получения подтверждения.
2. **Механизмы подтверждения**: Получатель регулярно отправляет подтверждения с указанием количества успешно полученных данных, что позволяет отправителю обновлять размер окна приема.

4 Инициализация соединений в сетевых протоколах.

### TCP (Transmission Control Protocol)

TCP — это протокол ориентированный на соединение, что означает, что перед началом передачи данных необходимо установить соединение. Процесс установления соединения в TCP включает следующие шаги:

1. **Трехсторонний рукопожатие (Three-way Handshake)**:
    - **SYN**: Инициирующий хост отправляет SYN пакет, чтобы начать установление соединения, указывая свой начальный порядковый номер.
    - **SYN-ACK**: Получающий хост отвечает пакетом SYN-ACK, подтверждая получение SYN и отправляя свой собственный начальный порядковый номер.
    - **ACK**: Инициирующий хост отправляет ACK для подтверждения получения SYN-ACK, завершая процесс установления соединения.

Этот процесс обеспечивает согласование начальных порядковых номеров и подтверждение готовности обеих сторон к передаче данных.

### UDP (User Datagram Protocol)

UDP — это протокол без установления соединения, что означает, что данные могут быть отправлены без предварительного установления соединения между хостами. Основные характеристики включают:

- **Отсутствие рукопожатия**: Данные могут быть отправлены без предварительного рукопожатия или другой формы установления соединения.
- **Простота отправки**: Отправляющий хост может просто вставить данные в дейтаграмму и отправить её на IP-адрес получателя с указанием номера порт

5 Маски адреса и нотации в сетевых адресах.

### Маска сети (Subnet Mask)

Маска сети используется в IPv4 для разделения адреса на сетевую и хостовую части. Маска сети это битовая маска, которая применяется к IP-адресу с помощью операции побитового И (AND), чтобы извлечь адрес сети.

- **Пример**: Если IP-адрес компьютера — 192.168.1.104, и маска сети — 255.255.255.0, то адрес сети будет 192.168.1.0. Маска сети 255.255.255.0 указывает, что первые три октета адреса (192.168.1) являются адресом сети, а последний октет (104) — адресом хоста в этой сети.

### CIDR Notation (Classless Inter-Domain Routing)

CIDR — это способ аллокации IP-адресов и маршрутизации, который более гибкий, чем традиционная классовая адресация. В нотации CIDR адрес записывается как обычный IP-адрес, за которым следует слэш (/) и число, указывающее количество битов, используемых для сетевой части адреса.

- **Пример**: 192.168.1.104/24 — это CIDR-нотация, где 192.168.1.104 — это IP-адрес, а /24 (эквивалент маски 255.255.255.0) указывает, что первые 24 бита адреса являются сетевой частью. Это означает, что все устройства с адресами от 192.168.1.0 до 192.168.1.255 находятся в одной сети.

### Применение

Маски сети и CIDR используются для:

- **Разработки сетевой архитектуры**: Определение подсетей и планирование адресного пространства.
- **Маршрутизации**: Указание маршрутизаторам, какие IP-адреса находятся в одной сети, и как направлять пакеты.
- **Безопасности**: Ограничение доступа к сетям и управление трафиком.

6 Как отличить разные классы IPv6 адресов визуально и где применяется каждый.

### 1. Unicast

**Описание**: Адрес Unicast используется для одноадресной передачи, то есть пакеты отправляются с одного источника к одному получателю.

- **Пример**: `2001:0db8:85a3:0000:0000:8a2e:0370:7334`
- **Применение**: Чаще всего используются в интернете для непосредственной коммуникации между двумя устройствами.

### 2. Multicast

**Описание**: Адрес Multicast используется для многоадресной передачи, то есть пакеты отправляются с одного источника к множеству получателей.

- **Пример**: `FF00::/8` (первые 8 бит всегда `FF`)
- **Применение**: Используются для потоковой передачи мультимедиа, онлайн-игр и других приложений, где один источник передает данные множеству получателей.

### 3. Anycast

**Описание**: Адреса Anycast позволяют пакетам быть доставленными к одному из множества интерфейсов, обычно ближайшему по маршруту. Внешне адрес Anycast неотличим от Unicast.

- **Пример**: Любой Unicast адрес, используемый в качестве Anycast.
- **Применение**: Используется для маршрутизации в сетях CDN (сети доставки контента), DNS и других сервисов, где важна скорость ответа.

### Визуальное различие

Основное визуальное различие между классами адресов IPv6 заключается в их начальных битах, которые определяют префикс адреса. Например, Link-Local начинается с `FE80`, а Multicast — с `FF`. Эти префиксы указывают на тип адреса и его предназначение.

7 Принципы и реализация NAT (Network Address Translation).

**Network Address Translation (NAT)** — это метод, используемый в сетевых устройствах (например, маршрутизаторах), чтобы позволить множеству устройств в частной локальной сети (LAN) делиться одним или несколькими общедоступными IP-адресами для доступа в Интернет. Это позволяет экономить IP-адреса, скрывает внутреннюю структуру сети от внешнего мира и повышает безопасность сети.

### Ключевые принципы NAT:

1. **Экономия адресов**: Основная цель NAT — сокращение потребности в уникальных глобальных IP-адресах. NAT позволяет множеству устройств использовать один общедоступный IP-адрес для доступа в Интернет.
2. **Приватность и безопасность**: NAT предоставляет дополнительный уровень изоляции для устройств в сети, так как внешние системы не могут напрямую адресовать какое-либо конкретное устройство внутри сети.
3. **Типы NAT**: Существуют разные типы NAT, включая Static NAT, Dynamic NAT и Port Address Translation (PAT), каждый из которых решает различные задачи в зависимости от потребностей сети.

### Реализация NAT

### Static NAT

**Static NAT** предназначен для постоянного отображения одного внутреннего IP-адреса на один внешний IP-адрес. Это полезно, когда устройству внутри сети требуется постоянный доступ из Интернета, например, для веб-сервера.

- **Пример**: Внутренний IP 192.168.0.10 всегда транслируется в внешний IP 203.0.113.10.

### Dynamic NAT

**Dynamic NAT** автоматически отображает внутренний IP-адрес на один из пула доступных внешних IP-адресов. Он обеспечивает большую гибкость и эффективность использования доступных публичных IP-адресов.

- **Пример**: Пул внешних адресов 203.0.113.10 - 203.0.113.20 может использоваться для динамической трансляции адресов из внутренней сети.

### Port Address Translation (PAT), известный также как NAT Overload

**PAT** использует один внешний IP-адрес и различные порты для отображения множества внутренних IP-адресов. Это самый распространенный тип NAT в домашних и малых офисных сетях, где множество устройств используют один внешний IP-адрес.

- **Пример**: Все устройства внутри сети могут иметь внешний IP-адрес 203.0.113.10, но различаются портами TCP или UDP, используемыми для уникальной идентификации сессий.

8 Сравнение моделей OSI и TCP/IP все про них

Модели OSI (Open Systems Interconnection) и TCP/IP (Transmission Control Protocol/Internet Protocol) — это две основные концептуальные модели, которые описывают, как должны взаимодействовать различные технологии в сетях. Несмотря на различия, обе модели оказали значительное влияние на развитие сетевых протоколов и архитектуры.

### Модель OSI

Разработана Международной организацией по стандартизации (ISO) в 1984 году, модель OSI представляет собой теоретическую семислойную модель, которая описывает серии этапов, через которые должна проходить информация в сетевых взаимодействиях.

**Слои модели OSI:**

1. **Физический (Physical)**: Передача и прием неструктурированных сырых бит данных через физическое соединение.
2. **Канальный (Data Link)**: Обработка ошибок, которые могли возникнуть на физическом уровне; управление доступом к среде.
3. **Сетевой (Network)**: Определение маршрута (роутинг) пакетов от отправителя к получателю.
4. **Транспортный (Transport)**: Полная доставка данных, управление потоком, обработка ошибок и контроль передачи.
5. **Сеансовый (Session)**: Управление сеансами связи между приложениями.
6. **Представления (Presentation)**: Преобразование данных в формат, пригодный для приложений (шифрование, сжатие данных).
7. **Прикладной (Application)**: Различные прикладные процессы получают доступ к сетевым службам.

### Модель TCP/IP

Разработана как часть проекта DARPA для создания глобальной сети, которая впоследствии стала основой интернета. Модель TCP/IP обычно описывается как имеющая четыре уровня и была реализована в начале 1970-х.

**Слои модели TCP/IP:**

1. **Сетевой интерфейс (Network Interface)**: Аналогичен совокупности физического и канального слоев OSI.
2. **Интернет (Internet)**: Определяет IP-адреса и маршрутизацию пакетов, аналогичен сетевому слою OSI.
3. **Транспорт (Transport)**: Отвечает за доставку данных от отправителя к получателю, аналогичен транспортному слою OSI.
4. **Приложения (Application)**: Объединяет три верхних слоя модели OSI (сеансовый, представления и прикладной) в один слой.

### Основные различия

1. **Количество слоев**: OSI состоит из 7 слоев, в то время как TCP/IP имеет 4 слоя.
2. **Стандартизация и адаптивность**: OSI предлагает строгую стандартизацию каждого уровня, что облегчает совместимость и разработку продуктов, но затрудняет адаптацию к новым технологиям. TCP/IP более гибок в этом отношении.
3. **Модель vs реализация**: OSI - это идеализированная модель, которая не была принята так широко, как TCP/IP, который представляет собой и модель, и конкретную реализацию, фактически используемую в Интернете.
4. **Уровень сеанса и уровень представления**: Отсутствуют в модели TCP/IP, где их функциональность либо интегрирована в прикладной слой, либо реализуется протоколами прикладного уровня.

9 Иерархия построения сетей
Понятия и данные, используемые в моделях OSI и TCP/IP.
Структура пакета TCP.

### Понятия и данные, используемые в моделях OSI и TCP/IP

Модели OSI и TCP/IP разрабатываются на базе набора принципов и понятий, которые помогают систематизировать и унифицировать процесс передачи данных в сетях. Основные понятия включают:

- **Энкапсуляция**: Данные на вышестоящих слоях оборачиваются заголовками нижестоящих слоев.
- **Мультиплексирование и демультиплексирование**: На транспортном слое происходит определение сессий потоков данных с помощью портов.
- **Маршрутизация и коммутация**: На сетевом слое данные направляются по оптимальным маршрутам.
- **Управление потоком и ошибками**: На транспортном слое обеспечивается доставка данных и контроль за их целостностью.

### Структура пакета TCP

Пакет TCP (или сегмент) состоит из заголовка и сегмента данных. Заголовок содержит важную информацию, необходимую для доставки пакета к месту назначения и его корректной обработки.

**Структура заголовка TCP включает следующие поля:**

1. **Порт источника (Source Port) и порт назначения (Destination Port)**: Указывают точки подключения на отправляющем и получающем устройствах.
2. **Порядковый номер (Sequence Number)**: Номер первого байта данных в сегменте или, если установлен флаг SYN, номер, предшествующий первому байту данных.
3. **Номер подтверждения (Acknowledgment Number)**: Если установлен флаг ACK, это поле содержит значение следующего ожидаемого байта.
4. **Длина заголовка (Data Offset)**: Размер заголовка TCP в 32-битных словах.
5. **Флаги (Flags)**: Управляющие флаги, такие как SYN, ACK, FIN, RST, PSH и URG.
6. **Размер окна (Window Size)**: Размер окна приемника, контролирующий объем данных, который отправитель может передать.
7. **Контрольная сумма (Checksum)**: Используется для обнаружения ошибок в заголовке и данных.
8. **Указатель срочности (Urgent Pointer)**: Указывает конец срочных данных.
9. **Опции (Options)**: Необязательное поле, используемое для установления максимального размера сегмента, масштабирования окна и других параметров.
10. **Данные (Data)**: Актуальные данные пользователя.

10 Байтовое и битовое заполнение (Byte and Bit Stuffing) и их применение как и избежать и почему это есть и как и когда что.

Байтовое и битовое заполнение (byte and bit stuffing) — это техники, используемые в передаче данных для обеспечения прозрачности данных и управления потоком в коммуникационных протоколах. Эти методы позволяют отправителю вставлять дополнительные биты или байты в передаваемые данные, чтобы избежать определённых последовательностей, которые могут быть интерпретированы как управляющие команды.

### Битовое заполнение (Bit Stuffing)

**Описание**: В битовом заполнении вставляются дополнительные биты в передаваемые данные, чтобы предотвратить появление последовательностей бит, которые могут быть интерпретированы как флаги или другие специальные сигналы.

**Пример использования**: В HDLC (High-level Data Link Control) и других протоколах основанных на битовой синхронизации, флаг, означающий начало и конец кадра, обычно представлен как `01111110`. Чтобы избежать ложного распознавания начала или конца кадра в середине данных, если в потоке данных встречается последовательность из пяти подряд идущих `1`, автоматически добавляется `0` после этих пяти `1`.

**Применение**: Используется в синхронной передаче данных для обеспечения того, что управляющие символы не появляются в данных.

### Байтовое заполнение (Byte Stuffing)

**Описание**: Байтовое заполнение добавляет дополнительные байты в поток данных, чтобы обойти последовательности, которые могут быть интерпретированы как управляющие символы.

**Пример использования**: В протоколе Point-to-Point (PPP), если в потоке данных встречается управляющий символ (например, `0x7E`, который используется как флаг кадра), перед этим символом вставляется специальный байт "escape" (`0x7D`), и исходный управляющий байт изменяется путем побитовой операции XOR с `0x20`.

**Применение**: Используется в асинхронной и потоковой передаче данных, чтобы данные могли быть правильно интерпретированы на приемном конце без конфликта с управляющими символами.

### Почему это необходимо?

1. **Прозрачность данных**: Заполнение данных обеспечивает, что данные могут содержать любые последовательности бит или байт без риска неправильной интерпретации этих последовательностей как команд.
2. **Контроль потока**: В синхронных средах передачи данных, таких как HDLC, необходимо чётко обозначать начало и конец кадра, что и достигается с помощью методов заполнения.

### Как и когда выбирать метод?

- **Битовое заполнение** обычно используется в синхронных передачах, где структура и размер кадра строго регулируются и где важна каждая единица информации.
- **Байтовое заполнение** чаще применяется в асинхронных и полудуплексных передачах, где байты данных могут быть интерпретированы в разных контекстах и где структура передачи менее строга.

11 Функции и значение MAC-адресов, их структура, и состояние адресов.
Значение OUI (Organizationally Unique Identifier) в MAC-адресах и что такое OUI в целом.

### Функции и значение MAC-адресов

**MAC-адрес (Media Access Control address)** — это уникальный идентификатор, назначаемый сетевым интерфейсам для связи на уровне канального слоя модели OSI (2-й уровень). MAC-адреса используются для обеспечения уникальной адресации устройств в локальной сети (LAN). Их основные функции и значение:

1. **Идентификация устройств в сети**: MAC-адрес служит уникальным идентификатором, что позволяет различным устройствам взаимодействовать друг с другом на уровне канального слоя.
2. **Управление доступом к среде**: Сетевые устройства используют MAC-адреса для определения, каким устройствам разрешено отправлять и принимать данные.
3. **Маршрутизация данных внутри локальных сетей**: При передаче данных в пределах одной сети маршрутизаторы и коммутаторы используют MAC-адреса для точного направления кадров.
4. **Безопасность и фильтрация**: MAC-адреса используются в системах безопасности и для настройки фильтрации трафика, позволяя разрешать или запрещать доступ определенным устройствам.

### Структура MAC-адресов

MAC-адрес состоит из 48 бит (6 байт), которые обычно представлены в формате шестнадцатеричных чисел, разделенных двоеточиями, дефисами или точками. Пример: `00:1A:2B:3C:4D:5E`.

**Структура MAC-адреса:**

1. **Первые 24 бита (OUI)**: Первая половина MAC-адреса называется OUI (Organizationally Unique Identifier) и назначается устройству производителем. Она идентифицирует организацию, которая зарегистрировала устройство.
2. **Последние 24 бита**: Вторая половина MAC-адреса назначается устройству производителем и является уникальной для каждого устройства, выпущенного данной организацией.

### Состояния MAC-адресов

1. **Уникальный (Unicast)**: Адрес используется для одноадресной передачи, при которой кадры направляются к конкретному устройству.
2. **Многоадресный (Multicast)**: Адрес идентифицирует группу устройств, и кадры, отправленные на такой адрес, доставляются всем устройствам в группе.
3. **Широковещательный (Broadcast)**: Специальный MAC-адрес, состоящий из всех единиц (`FF:FF:FF:FF:FF:FF`), используется для отправки пакетов всем устройствам в локальной сети.

### Значение OUI (Organizationally Unique Identifier)

**OUI (Организационно уникальный идентификатор)** — это первые 24 бита MAC-адреса, которые определяют производителя устройства. OUI назначаются IEEE и обеспечивают уникальность адресов, производимых данной компанией.

**Значение OUI:**

1. **Идентификация производителя**: Каждый зарегистрированный производитель сетевых устройств получает уникальный OUI, что позволяет определять производителя по MAC-адресу устройства.
2. **Глобальная уникальность**: OUI обеспечивает уникальность первых 24 бит в MAC-адресах, предотвращая конфликты адресов между устройствами от разных производителей.

**Пример**: Если MAC-адрес начинается с `00:1A:2B`, то `00:1A:2B` — это OUI, который однозначно указывает на определенного производителя.

Таким образом, MAC-адреса и OUI играют важную роль в сетевом взаимодействии, обеспечивая уникальную адресацию устройств и поддержку работы локальных сетей.

12 Заголовки и рарпы

### Структура заголовков IPv4 и IPv6

**IPv4 (Internet Protocol version 4)** и **IPv6 (Internet Protocol version 6)** имеют разные структуры заголовков, отражающие их особенности и возможности.

### Структура заголовка IPv4

Заголовок IPv4 имеет фиксированную минимальную длину 20 байт и включает множество полей для управления передачей данных. Основные поля заголовка IPv4:

1. **Version (4 бита)**: Указывает версию протокола (для IPv4 — значение 4).
2. **Header Length (IHL) (4 бита)**: Длина заголовка в 32-битных словах.
3. **Type of Service (ToS) (8 бит)**: Поле для указания приоритетов и качества обслуживания.
4. **Total Length (16 бит)**: Общая длина пакета, включая заголовок и данные.
5. **Identification (16 бит)**: Идентификатор пакета, используемый для фрагментации.
6. **Flags (3 бита)**: Управление фрагментацией.
7. **Fragment Offset (13 бит)**: Смещение фрагмента.
8. **Time to Live (TTL) (8 бит)**: Указывает, сколько хопов (переходов) пакет может пройти, прежде чем будет отброшен.
9. **Protocol (8 бит)**: Указывает протокол верхнего уровня (например, TCP, UDP).
10. **Header Checksum (16 бит)**: Контрольная сумма для проверки ошибок в заголовке.
11. **Source Address (32 бита)**: IP-адрес отправителя.
12. **Destination Address (32 бита)**: IP-адрес получателя.
13. **Options (необязательное поле)**: Может использоваться для различных дополнительных функций.

### Структура заголовка IPv6

Заголовок IPv6 имеет упрощенную и фиксированную структуру по сравнению с IPv4, с длиной в 40 байт. Основные поля:

1. **Version (4 бита)**: Указывает версию протокола (для IPv6 — значение 6).
2. **Traffic Class (8 бит)**: Определяет приоритеты передачи пакетов.
3. **Flow Label (20 бит)**: Идентификатор потока пакетов для поддержки потоковой передачи данных.
4. **Payload Length (16 бит)**: Длина полезной нагрузки (данные, включая дополнительные заголовки).
5. **Next Header (8 бит)**: Указывает следующий заголовок (эквивалент поля Protocol в IPv4), используется для указания заголовков верхнего уровня или расширенных заголовков.
6. **Hop Limit (8 бит)**: Указывает максимальное количество хопов, аналогично TTL в IPv4.
7. **Source Address (128 бит)**: IPv6-адрес отправителя.
8. **Destination Address (128 бит)**: IPv6-адрес получателя.

### Протоколы ARP и RARP

### ARP (Address Resolution Protocol)

**Назначение**: Протокол ARP используется для определения MAC-адреса устройства в локальной сети, зная его IP-адрес. Это необходимо для передачи данных на уровне канального слоя, так как Ethernet использует MAC-адреса.

**Как работает ARP**:

1. Устройство отправляет ARP-запрос с просьбой: "Каков MAC-адрес устройства с этим IP-адресом?"
2. Устройство с указанным IP-адресом отвечает ARP-ответом, содержащим свой MAC-адрес.
3. Ответ кэшируется для последующего использования.

**Применение**: ARP используется в сетях IPv4 для преобразования IP-адресов в MAC-адреса.

### RARP (Reverse Address Resolution Protocol)

**Назначение**: Протокол RARP используется для определения IP-адреса устройства по известному MAC-адресу. Это полезно для устройств, которые не имеют своего IP-адреса, например, беспроводных или тонких клиентов при загрузке.

**Как работает RARP**:

1. Устройство отправляет запрос RARP, указывая свой MAC-адрес и запрашивая IP-адрес.
2. Специальный сервер (RARP-сервер) отвечает, предоставляя соответствующий IP-адрес.

**Применение**: RARP был использован в ранних сетях, но в основном устарел и заменен более современными протоколами, такими как DHCP (Dynamic Host Configuration Protocol).

Таким образом, ARP и RARP обеспечивают преобразование между уровнями сетевой и канальной адресации, что критически важно для работы сетей, особенно для передачи данных на канальном уровне.

—Механизмы управления окнами в сетевых протоколах.
Улучшения и дополнения TCP, включая механизмы, предложенные Кларком, все актуальные дополнения TCP.

## 9. ICMP (Internet Control Message Protocol)

**ICMP** — протокол уровня сетевого слоя (уровень 3 OSI), используемый для передачи управляющих и диагностических сообщений между узлами сети. Он помогает в обнаружении ошибок и управлении сетью.

### Основные функции ICMP:

1. **Диагностика сети:**
    - **Ping:** Использует ICMP Echo Request и Echo Reply сообщения для проверки доступности узла.
    - **Traceroute:** Использует ICMP Time Exceeded сообщения для определения маршрута до целевого узла.
2. **Сообщения об ошибках:**
    - **Destination Unreachable:** Уведомляет отправителя о невозможности доставки пакета (например, нет маршрута, порт недоступен).
    - **Time Exceeded:** Указывает, что пакет превысил максимальное время жизни (TTL).
    - **Parameter Problem:** Сообщает о проблемах с параметрами заголовка IP-пакета.
    - **Redirect:** Указывает отправителю использовать другой маршрут для доставки пакетов к определенному адресу.
3. **Управление сетью:**
    - **Source Quench:** (Устаревший) Просил отправителя замедлить отправку пакетов.

### Структура ICMP-сообщения:

- **Тип (Type):** Указывает тип сообщения (например, Echo Request — 8, Echo Reply — 0).
- **Код (Code):** Дополняет информацию о типе (например, для Destination Unreachable могут быть разные причины).
- **Контрольная сумма (Checksum):** Для проверки целостности сообщения.
- **Поле данных:** В зависимости от типа сообщения, могут содержать дополнительную информацию (например, оригинальный IP-заголовок и первые 8 байт данных).

### Примеры использования:

- **Ping:** Проверка доступности сервера или узла в сети.
- **Traceroute:** Определение пути и задержки между узлами сети.
- **Обнаружение ошибок:** Сетевые устройства могут отправлять ICMP-сообщения при возникновении проблем с доставкой пакетов.

## 10. TTL (Time To Live)

**TTL (Time To Live)** — поле в заголовке IP-пакета, определяющее максимальное количество промежуточных узлов (маршрутизаторов), через которые пакет может пройти перед удалением. Первоначально оно устанавливается отправителем и уменьшается на каждом маршрутизаторе, через который проходит пакет. Когда TTL достигает нуля, пакет отбрасывается, и отправителю отправляется ICMP-сообщение об истечении времени жизни.

### Основные функции TTL:

1. **Предотвращение зацикливания пакетов:**
    - Если пакет застрял в петле маршрутизации, TTL гарантирует, что он будет удален после определенного количества пересылок, предотвращая перегрузку сети.
2. **Определение расстояния:**
    - При использовании инструментов, таких как **Traceroute**, TTL используется для измерения количества узлов между отправителем и получателем.

### Значение TTL:

- **Стандартные значения:**
    - **Unix-подобные системы:** Обычно начинают с 64.
    - **Windows:** Обычно начинают с 128.
    - **Некоторые устройства:** Могут использовать другие значения, например, 255.
- **Изменение TTL:**
    - Административные настройки могут изменять значение TTL для определенных приложений или устройств.
    - Некоторые системы увеличивают или уменьшают TTL для обеспечения специфических требований безопасности или маршрутизации.

### Использование TTL в безопасности:

- **Анализ TTL:**
    - Анализ значения TTL может помочь определить операционную систему отправителя, поскольку разные ОС устанавливают разные начальные значения TTL.
    - Может использоваться в методах определения геолокации или идентификации устройств.
- **Атаки и обходы:**
    - Злоумышленники могут изменять TTL для маскировки происхождения пакетов или обхода некоторых фильтров и ограничений.

### Пример использования TTL:

- **Traceroute:**
    - Отправляет серию пакетов с увеличивающимся значением TTL (начиная с 1).
    - Каждый маршрутизатор, через который проходит пакет, уменьшает TTL и, когда он достигает нуля, отправляет ICMP Time Exceeded сообщение.
    - Таким образом, можно определить маршрут и задержки между узлами сети.

## 11. Все популярные расширения TCP

**TCP (Transmission Control Protocol)** имеет несколько расширений и опций, которые улучшают его функциональность, производительность и безопасность. Рассмотрим наиболее популярные из них:

### 1. **TCP Fast Open (TFO):**

- **Описание:** Ускоряет установку TCP-соединений, позволяя отправлять данные уже в первом SYN-пакете.
- **Преимущества:** Снижает задержку при установлении соединения, улучшая производительность для коротких запросов, например, в веб-приложениях.
- **Требования:** Поддержка как клиентом, так и сервером, а также механизмов кэширования секретов.

### 2. **Selective Acknowledgments (SACK):**

- **Описание:** Позволяет получателю указывать конкретные блоки данных, которые были получены успешно, несмотря на пропуски.
- **Преимущества:** Улучшает эффективность восстановления после потери пакетов, снижая количество повторных передач.
- **Применение:** Особенно полезно в сетях с высокой потерей пакетов или большой задержкой.

### 3. **Window Scaling:**

- **Описание:** Увеличивает размер окна TCP, позволяя поддерживать более высокие скорости передачи данных на высокопроизводительных сетях.
- **Преимущества:** Улучшает пропускную способность TCP-соединений, особенно на широкополосных и высокозадерживающих сетях.
- **Механизм:** Использует масштабируемый фактор для увеличения окна скольжения.

### 4. **Timestamp Option:**

- **Описание:** Добавляет временные метки в TCP-сегменты для измерения задержек и улучшения управления перегрузкой.
- **Преимущества:** Улучшает алгоритмы управления перегрузкой, такие как TCP Vegas и другие адаптивные механизмы.
- **Использование:** Помогает в оценке RTT (Round-Trip Time) и предотвращении неправильных повторных передач.

### 5. **TCP Selective Acknowledgment Permitted (SACK Permitted):**

- **Описание:** Опция, уведомляющая об обмене SACK между узлами.
- **Преимущества:** Позволяет использовать SACK только если обе стороны поддерживают эту опцию.

### 6. **MPTCP (Multipath TCP):**

- **Описание:** Расширение TCP, позволяющее использовать несколько путей для передачи данных одновременно.
- **Преимущества:** Повышает надежность и скорость передачи данных, балансируя нагрузку между разными сетевыми интерфейсами (например, Wi-Fi и мобильные сети).
- **Применение:** Используется в мобильных устройствах и сетях с несколькими активными интерфейсами.

### 7. **TCP Congestion Control Algorithms:**

TCP поддерживает различные алгоритмы управления перегрузкой, такие как:

- **Reno:** Классический алгоритм с быстрым восстановлением и обнаружением перегрузки.
- **CUBIC:** Оптимизирован для высокоскоростных и долгих соединений, используется по умолчанию в Linux.
- **BBR (Bottleneck Bandwidth and Round-trip propagation time):** Фокусируется на максимизации пропускной способности, минимизируя задержки.
- **Westwood:** Оптимизирован для беспроводных сетей с переменной пропускной способностью.

### 8. **TCP Authentication Option (TCP-AO):**

- **Описание:** Обеспечивает аутентификацию TCP-соединений.
- **Преимущества:** Улучшает безопасность, предотвращая атаки на установление соединений и манипуляции данными.

### 9. **TCP Compression:**

- **Описание:** Сокращает размер заголовков TCP для уменьшения накладных расходов.
- **Преимущества:** Повышает эффективность передачи данных, особенно в сетях с ограниченной пропускной способностью.

### 10. **ECN (Explicit Congestion Notification):**

- **Описание:** Позволяет узлам сети сигнализировать о перегрузке без необходимости сбрасывать пакеты.
- **Преимущества:** Снижает задержки и улучшает пропускную способность при перегрузках.

### Преимущества расширений TCP:

- **Повышение производительности:** Ускорение установления соединений, улучшение пропускной способности.
- **Улучшение надежности:** Более эффективное управление потерями пакетов и перегрузками.
- **Расширение функциональности:** Поддержка мультипутевых соединений, улучшение безопасности.

### Внедрение и совместимость:

- **Совместимость:** Не все расширения поддерживаются всеми системами и устройствами. Важно проверять поддержку на обеих сторонах соединения.
- **Обратная совместимость:** Многие расширения разработаны таким образом, чтобы не нарушать существующие соединения и работать с узлами, которые их не поддерживают.

---

## 12. MAC-адреса очень подробно

### Что такое MAC-адрес

**MAC-адрес (Media Access Control address)** — уникальный идентификатор, присваиваемый сетевому интерфейсу для связи на канальном уровне модели OSI. Он используется для идентификации устройств в локальной сети и обеспечения передачи данных между ними.

### Структура MAC-адреса

- **Длина:** 48 бит (6 байт).
- **Формат:** Представляется как шесть групп по два шестнадцатеричных числа, разделенных двоеточиями или дефисами (например, `00:1A:2B:3C:4D:5E`).

### Разделение MAC-адреса

1. **OUI (Organizationally Unique Identifier):**
    - **Первые 24 бита (первые три байта):** Определяют производителя устройства.
    - **Пример:** `00:1A:2B` может быть присвоен компанией Apple Inc.
2. **Идентификатор устройства:**
    - **Последние 24 бита (последние три байта):** Уникальны для каждого устройства, произведенного данным производителем.
    - **Гарантируют уникальность адреса в пределах производителя.**

### Типы MAC-адресов

1. **Уникальные (Unicast):**
    - Используются для идентификации одного конкретного устройства.
    - Первый байт имеет младший бит равный 0 (например, `00:1A:2B:3C:4D:5E`).
2. **Мультикастовые (Multicast):**
    - Используются для передачи данных группе устройств.
    - Первый байт имеет младший бит равный 1 (например, `01:00:5E:00:00:FB`).
3. **Широковещательные (Broadcast):**
    - Специальный адрес `FF:FF:FF:FF:FF:FF`, означающий отправку данных всем устройствам в локальной сети.

### Специальные MAC-адреса

- **Адреса локального администратора:** Позволяют создавать приватные MAC-адреса без конфликтов с официальными.
- **Адреса, соответствующие виртуальным интерфейсам:** Используются в виртуальных машинах и контейнерах.

### Присвоение MAC-адресов

- **Производители оборудования:** Присваивают OUI, после чего генерируют уникальные идентификаторы для своих устройств.
- **Гарантия уникальности:** В производственных процессах используются механизмы, предотвращающие дублирование MAC-адресов.

### Программирование и изменение MAC-адресов

- **Изменение MAC-адреса (MAC Spoofing):** Возможность изменить MAC-адрес на программном уровне для различных целей, таких как тестирование или обход ограничений сети.
- **Инструменты:** Находятся в большинстве операционных систем (например, `ifconfig` или `ip` в Unix, специальные утилиты в Windows).

### Применение MAC-адресов

1. **Электронная коммутация (Switching):**
    - Коммутаторы используют MAC-адреса для определения, куда направлять кадры данных.
    - Таблицы MAC-адресов (MAC таблицы) хранят соответствие между MAC-адресами и портами коммутатора.
2. **Фильтрация и безопасность:**
    - **MAC-фильтрация:** Позволяет разрешать или запрещать доступ к сети на основе MAC-адресов.
    - **Контроль доступа:** Некоторые сети используют MAC-адреса для ограничения доступа к определенным ресурсам.
3. **Адресация в протоколах:**
    - **ARP (Address Resolution Protocol):** Используется для преобразования IP-адресов в MAC-адреса в локальной сети.
    - **DHCP (Dynamic Host Configuration Protocol):** Использует MAC-адреса для присвоения IP-адресов устройствам.
4. **Отслеживание устройств:**
    - **Сетевые администраторы:** Используют MAC-адреса для мониторинга и управления устройствами в сети.
    - **Инструменты анализа сети:** Такие как Wireshark, позволяют отслеживать трафик по MAC-адресам.

### Преимущества MAC-адресов

- **Уникальность:** Гарантирует, что каждое устройство в локальной сети имеет уникальный идентификатор.
- **Простота:** Легко идентифицировать устройства на канальном уровне без необходимости знания сетевых адресов.
- **Независимость от сетевых адресов:** MAC-адреса остаются постоянными, даже если IP-адреса изменяются.

### Недостатки и ограничения

- **Ограниченность в масштабируемости:** Не предназначены для глобальной адресации, только для локальных сетей.
- **Безопасность:** Возможны атаки, такие как MAC-спуфинг, где злоумышленник подменяет MAC-адрес для получения несанкционированного доступа.
- **Необходимость управления:** В больших сетях управление MAC-адресами может быть сложным без автоматизированных инструментов.

### Безопасность и защита MAC-адресов

- **Port Security на коммутаторах:** Позволяет ограничивать количество MAC-адресов, которые могут быть подключены к определенному порту.
- **802.1X:** Протокол аутентификации на уровне канального уровня, использующий MAC-адреса для управления доступом к сети.
- **VPN и шифрование:** Помогают скрыть реальные MAC-адреса от внешних наблюдателей.

### Виртуальные MAC-адреса

- **Виртуальные машины и контейнеры:** Могут иметь собственные MAC-адреса, управляемые гипервизорами или оркестраторами контейнеров.
- **Балансировка нагрузки и отказоустойчивость:** Используют виртуальные MAC-адреса для управления перенаправлением трафика между несколькими физическими узлами.

---

## 13. Сокеты в целом

**Сокеты** — это программный интерфейс (API), используемый для организации связи между различными процессами через сеть. Они предоставляют механизм для передачи данных между приложениями, работающими на одном или разных компьютерах.

### Основные понятия:

1. **Сокет (Socket):**
    - Абстракция, представляющая конечную точку связи между двумя узлами сети.
    - Каждый сокет привязан к конкретному протоколу (например, TCP или UDP) и адресу (IP и порт).
2. **Адрес сокета:**
    - **IP-адрес:** Уникальный идентификатор устройства в сети.
    - **Порт:** Логический идентификатор приложения или службы на устройстве.

### Типы сокетов:

1. **Stream Sockets (TCP):**
    - Обеспечивают надежное, ориентированное на соединение соединение.
    - Гарантируют доставку данных в том порядке, в котором они были отправлены.
    - Пример использования: веб-серверы, базы данных.
2. **Datagram Sockets (UDP):**
    - Обеспечивают ненадежное, без соединения соединение.
    - Не гарантируют доставку или порядок доставки данных.
    - Пример использования: онлайн-игры, стриминг мультимедиа.
3. **Raw Sockets:**
    - Позволяют работать с низкоуровневыми протоколами, предоставляя доступ к заголовкам и данным пакетов.
    - Используются для специальных задач, таких как создание собственных протоколов или анализ трафика.
    - Требуют повышенных привилегий.
4. **UNIX Domain Sockets:**
    - Используются для межпроцессного взаимодействия на одной машине.
    - Более быстрые по сравнению с сетевыми сокетами, так как не требуют сетевого стека.

### Основные операции с сокетами:

1. **Создание сокета:**
    - Используется системный вызов `socket()`, где указываются семейство протоколов (например, AF_INET для IPv4), тип сокета (SOCK_STREAM или SOCK_DGRAM) и протокол (обычно 0 для автоматического выбора).
2. **Привязка сокета (bind):**
    - Ассоциирует сокет с конкретным IP-адресом и портом на устройстве.
    - Необходимо для серверов, ожидающих входящих соединений.
3. **Прослушивание (listen):**
    - Для TCP-сокетов, переводит сокет в состояние ожидания входящих соединений.
    - Определяет очередь ожидающих подключений.
4. **Принятие соединения (accept):**
    - Принимает входящее соединение на сервере, создавая новый сокет для общения с клиентом.
5. **Установка соединения (connect):**
    - Для клиентов, устанавливает соединение с сервером, указывая IP-адрес и порт сервера.
6. **Отправка и получение данных:**
    - **send() / recv():** Отправляют и получают данные по сокету.
    - **sendto() / recvfrom():** Используются для UDP-сокетов, позволяя указывать адрес получателя.
7. **Закрытие сокета (close):**
    - Завершает соединение и освобождает ресурсы, связанные с сокетом.

### Примеры использования сокетов:

- **Клиент-серверные приложения:** Веб-серверы, почтовые серверы, FTP-серверы.
- **Реалтайм приложения:** Онлайн-игры, чаты, видеоконференции.
- **Межпроцессное взаимодействие:** Локальные приложения используют UNIX Domain Sockets для обмена данными между процессами.

### Доп штуки

Дополнения: TCP cognetion (за перезагрузки отвечает), Fast Retransmit/Recovery (быстрое отправление утерянных пакетов без ожидания time out), Tcp HyStart - Этот алгоритм является улучшением стандартного **Slow Start**. В отличие от базового алгоритма, где скорость отправки данных увеличивается экспоненциально, **HyStart** пытается динамически адаптироваться к реальной пропускной способности сети, что позволяет избежать чрезмерной потери пакетов вначале передачи и улучшить производительность. TCP fast open - отправляем данные до полного соединения. TCP Window Scaling - В стандартном TCP размер окна для управления потоком ограничен 65 535 байтами. **Window Scaling** позволяет увеличить это ограничение до 1 ГБ.

**Unicast**, **Anycast** и **Multicast** — это разные способы адресации и отправки данных в компьютерных сетях, каждый из которых имеет свое назначение и применяется в различных сценариях. Давайте разберем, что такое каждый из этих типов адресации, а также как данные передаются в подсетях.

### **Unicast** — это способ передачи данных, при котором данные отправляются от одного источника к одному получателю. Это самый распространенный способ адресации в компьютерных сетях.

**Принцип работы**: Когда данные передаются по принципу **unicast**, отправитель направляет данные только на конкретный адрес получателя. В TCP/IP сетях это обычно осуществляется с использованием одного IP-адреса для отправителя и одного IP-адреса для получателя.

### 2. **Anycast (Эникест)**

**Anycast** — это способ передачи данных, при котором данные отправляются от одного источника к ближайшему из группы получателей, имеющих одинаковый IP-адрес. То есть, в **anycast** несколько устройств могут иметь одинаковый IP-адрес, и данные всегда направляются на ближайшее устройство.

- **Принцип работы**: В отличие от unicast, где данные направляются на конкретное устройство, в anycast данные отправляются на ближайшее устройство с определенным адресом. Ближайшее устройство определяется с помощью маршрутизаторов, которые выбирают наиболее оптимальный путь для передачи данных.
- **Пример**: Это используется для балансировки нагрузки, например, когда несколько серверов DNS имеют одинаковые IP-адреса, и запросы направляются на ближайший сервер.

**Как данные передаются в подсети**:

- При использовании anycast данные отправляются на ближайший доступный получатель с этим IP-адресом. Это может быть сервер, который ближе к отправителю с точки зрения сетевого расстояния (наименьшее количество промежуточных маршрутизаторов).
- Если пакеты отправляются в сеть, которая использует anycast, маршрутизаторы определяют, какой сервер (с одинаковым IP-адресом) расположен ближе и пересылают пакет к нему.

### 3. **Multicast (Мультикаст)**

**Multicast** — это способ передачи данных, при котором данные отправляются от одного источника сразу нескольким получателям (группе). В отличие от unicast, где данные отправляются одному получателю, и anycast, где данные отправляются ближайшему получателю, multicast позволяет отправлять данные нескольким заранее определенным получателям, которые подписались на эту группу.

- **Принцип работы**: В multicast источники данных отправляют пакеты на специальный мультикастовый адрес (например, IP-адрес в диапазоне от 224.0.0.0 до 239.255.255.255 для IPv4). Только те устройства, которые подписались на эту группу (т.е. относятся к мультикастовой группе), будут получать эти данные.
- **Пример**: Потоковое видео или аудио, которое транслируется нескольким пользователям, например, видеоконференции или трансляции спортивных мероприятий. Устройства, подписавшиеся на группу, будут получать данные, но остальные устройства — нет.

**Как данные передаются в подсети**:

- В multicast данные передаются через маршрутизаторы, которые поддерживают multicast-адресацию. Маршрутизаторы проверяют подписки на группы и пересылают данные только тем устройствам, которые подписались на эту группу.

## 1. Создание сокета в WinAPI

В **WinAPI** для работы с сокетами используется набор функций, предоставляемых библиотекой `Ws2_32.lib`. Основные шаги для создания и использования сокета включают:

1. **Инициализация библиотеки Winsock**.
2. **Создание сокета** с помощью функции `socket()`.
3. **Настройка адресной структуры** (`sockaddr`).
4. **Привязка сокета к адресу и порту** (для серверов) с помощью `bind()`.
5. **Прослушивание входящих соединений** (для серверов) с помощью `listen()`.
6. **Принятие соединений** с помощью `accept()` (для серверов).
7. **Установка соединения** (для клиентов) с помощью `connect()`.
8. **Передача данных** с помощью `send()` и `recv()`.
9. **Закрытие сокета** с помощью `closesocket()` и очистка библиотеки Winsock с помощью `WSACleanup()`.

Thought for a couple of seconds

Продолжая тему сетевого программирования и работы с сокетами, давайте углубимся в детали создания сокетов с использованием **WinAPI (Windows API)**, рассмотрим все необходимые параметры, объясним, зачем указывать длину заголовка, и подробно разберём, что такое порт и почему он необходим.

## 1. Создание сокета в WinAPI

В **WinAPI** для работы с сокетами используется набор функций, предоставляемых библиотекой `Ws2_32.lib`. Основные шаги для создания и использования сокета включают:

1. **Инициализация библиотеки Winsock**.
2. **Создание сокета** с помощью функции `socket()`.
3. **Настройка адресной структуры** (`sockaddr`).
4. **Привязка сокета к адресу и порту** (для серверов) с помощью `bind()`.
5. **Прослушивание входящих соединений** (для серверов) с помощью `listen()`.
6. **Принятие соединений** с помощью `accept()` (для серверов).
7. **Установка соединения** (для клиентов) с помощью `connect()`.
8. **Передача данных** с помощью `send()` и `recv()`.
9. **Закрытие сокета** с помощью `closesocket()` и очистка библиотеки Winsock с помощью `WSACleanup()`.

### Пример базового сервера на C с использованием WinAPI

```c
c
Copy code
#include <winsock2.h>#include <ws2tcpip.h>#include <stdio.h>// Не забудьте добавить Ws2_32.lib в параметры компиляции

int main() {
    WSADATA wsaData;
    SOCKET ListenSocket = INVALID_SOCKET, ClientSocket = INVALID_SOCKET;
    struct sockaddr_in serverAddr, clientAddr;
    int iResult;
    int clientAddrSize = sizeof(clientAddr);

    // 1. Инициализация Winsock
    iResult = WSAStartup(MAKEWORD(2,2), &wsaData);
    if (iResult != 0) {
        printf("WSAStartup failed: %d\n", iResult);
        return 1;
    }

    // 2. Создание сокета
    ListenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (ListenSocket == INVALID_SOCKET) {
        printf("Ошибка создания сокета: %ld\n", WSAGetLastError());
        WSACleanup();
        return 1;
    }

    // 3. Настройка адресной структуры
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_addr.s_addr = INADDR_ANY; // 0.0.0.0
    serverAddr.sin_port = htons(8080); // Порт 8080

    // 4. Привязка сокета к адресу и порту
    iResult = bind(ListenSocket, (struct sockaddr *)&serverAddr, sizeof(serverAddr));
    if (iResult == SOCKET_ERROR) {
        printf("bind failed with error: %d\n", WSAGetLastError());
        closesocket(ListenSocket);
        WSACleanup();
        return 1;
    }

    // 5. Прослушивание входящих соединений
    iResult = listen(ListenSocket, SOMAXCONN);
    if (iResult == SOCKET_ERROR) {
        printf("listen failed with error: %d\n", WSAGetLastError());
        closesocket(ListenSocket);
        WSACleanup();
        return 1;
    }

    printf("Ожидание соединений на порту 8080...\n");

    // 6. Принятие соединения
    ClientSocket = accept(ListenSocket, (struct sockaddr *)&clientAddr, &clientAddrSize);
    if (ClientSocket == INVALID_SOCKET) {
        printf("accept failed: %d\n", WSAGetLastError());
        closesocket(ListenSocket);
        WSACleanup();
        return 1;
    }

    printf("Соединение установлено с %s:%d\n", inet_ntoa(clientAddr.sin_addr), ntohs(clientAddr.sin_port));

    // Здесь можно добавить передачу данных с помощью send() и recv()

    // Закрытие сокетов
    closesocket(ClientSocket);
    closesocket(ListenSocket);
    WSACleanup();

    return 0;
}

```

## 2. Параметры функции `socket()`

Функция `socket()` используется для создания сокета и имеет следующую сигнатуру:

```c
c
Copy code
SOCKET socket(
  int af,      // Address family
  int type,    // Socket type
  int protocol // Protocol
);

```

### Параметры:

1. **af (Address Family)**:
    - **`AF_INET`**: IPv4.
    - **`AF_INET6`**: IPv6.
    - **`AF_UNIX`**: UNIX-доменные сокеты (на Windows обычно не используется).
2. **type (Тип сокета)**:
    - **`SOCK_STREAM`**: Потоковый сокет (используется с протоколом TCP).
    - **`SOCK_DGRAM`**: Дейтаграммный сокет (используется с протоколом UDP).
    - **`SOCK_RAW`**: Сырой сокет (для доступа к низкоуровневым протоколам).
3. **protocol (Протокол)**:
    - Обычно устанавливается в `0`, чтобы система автоматически выбрала подходящий протокол на основе заданных `af` и `type`.
    - Можно явно указать протокол, например, `IPPROTO_TCP` или `IPPROTO_UDP`.

### Пример создания UDP-сокета:

```c
c
Copy code
SOCKET udpSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

```

## 3. Зачем указывать длину заголовка?

Когда вы используете функции, такие как `bind()`, `connect()`, `accept()`, `recvfrom()` и `sendto()`, необходимо передавать указатель на структуру адреса (`sockaddr_in` или `sockaddr_in6` для IPv4 и IPv6 соответственно). Эти функции также требуют указания длины этой структуры.

### Причины необходимости указания длины:

1. **Гибкость**: Позволяет функциям работать с разными структурами адресов (например, IPv4 и IPv6) без жесткой привязки к конкретному размеру.
2. **Безопасность**: Предотвращает переполнение буфера, так как функция знает, сколько данных ей безопасно читать или записывать.
3. **Совместимость**: Обеспечивает совместимость с различными версиями и расширениями протоколов.

## 4. Что такое порт и зачем он нужен?

### Определение порта:

**Порт** — это 16-битное целое число (от 0 до 65535), которое используется для идентификации конкретного процесса или службы на компьютере в сети. В комбинации с IP-адресом порт позволяет направлять сетевые пакеты к правильному приложению или сервису.

### Зачем нужны порты:

1. **Множественные соединения**: Один IP-адрес может обслуживать множество приложений одновременно. Порты позволяют различать эти приложения.
2. **Маршрутизация данных**: Порты помогают системе операционной системе и сетевому оборудованию направлять входящие данные к соответствующему приложению.
3. **Безопасность**: Ограничивая доступ к определённым портам, можно контролировать, какие сервисы доступны извне.

### Классификация портов:

1. **Well-Known Ports (0–1023)**:
    - Зарезервированы для стандартных сервисов и протоколов.
    - Примеры:
        - **80**: HTTP
        - **443**: HTTPS
        - **21**: FTP
        - **25**: SMTP
2. **Registered Ports (1024–49151)**:
    - Зарегистрированы для определённых приложений и сервисов.
    - Используются сторонними приложениями и сервисами.
3. **Dynamic or Private Ports (49152–65535)**:
    - Используются для временных или частных соединений.
    - Обычно назначаются клиентским приложениям при установлении соединения.

### Пример использования портов:

- **Веб-сервер**: Обычно слушает на порту **80** (HTTP) или **443** (HTTPS).
- **FTP-сервер**: Использует порт **21** для управления соединением и порты **20** для передачи данных.
- **Клиентское приложение**: При установлении соединения с сервером использует динамический порт из диапазона **49152–65535**.

### Почему порты важны:

1. **Идентификация сервисов**: Позволяют различать разные сервисы на одном устройстве.
2. **Управление доступом**: Системы безопасности и фаерволы могут фильтровать трафик на основе портов.
3. **Эффективность коммуникации**: Оптимизируют передачу данных, направляя их непосредственно к нужному приложению.

## 5. Дополнительные понятия

### 0.0.0.0 vs 127.0.0.1

- **0.0.0.0**:
    - Специальный IP-адрес, обозначающий "все IPv4-адреса на локальном компьютере".
    - Используется серверными приложениями для прослушивания на всех доступных сетевых интерфейсах.
    - Пример: Если сервер привязан к `0.0.0.0`, он будет принимать соединения на всех IP-адресах устройства (например, LAN, Wi-Fi).
- **127.0.0.1**:
    - Локальный адрес (localhost), используемый для связи с самим собой.
    - Сервер, привязанный к `127.0.0.1`, будет доступен только с того же устройства.
    - Используется для тестирования и локальных сервисов.

### Пример:

```c
c
Copy code
// Привязка к 0.0.0.0 (все интерфейсы)
serverAddr.sin_addr.s_addr = INADDR_ANY;

// Привязка к 127.0.0.1 (локальный интерфейс)
inet_pton(AF_INET, "127.0.0.1", &serverAddr.sin_addr);

```

### DNS (Domain Name System)

**DNS** — система доменных имён, которая преобразует понятные человеку имена (например, `www.example.com`) в IP-адреса (например, `93.184.216.34`), используемые для идентификации устройств в сети.

### Как работает DNS:

1. **Запрос**: Когда вы вводите доменное имя в браузере, ваш компьютер отправляет запрос на DNS-сервер.
2. **Резолвинг**: DNS-сервер ищет соответствующий IP-адрес для данного доменного имени.
3. **Ответ**: DNS-сервер возвращает найденный IP-адрес вашему компьютеру.
4. **Соединение**: Ваш компьютер использует этот IP-адрес для установления соединения с нужным сервером.

## 1. Заголовок IPv4

**IPv4 (Internet Protocol version 4)** — это четвертая версия протокола Интернета, которая до сих пор широко используется для адресации и маршрутизации пакетов данных в сети. Заголовок IPv4 имеет фиксированную длину от 20 до 60 байт, в зависимости от наличия опций.

### Структура заголовка IPv4

| Поле | Длина (бит) | Описание |
| --- | --- | --- |
| Version | 4 | Версия протокола (для IPv4 значение всегда 4) |
| IHL (Internet Header Length) | 4 | Длина заголовка в 32-битных словах (минимум 5 слов = 20 байт) |
| Type of Service (ToS) | 8 | Классификация трафика и управление качеством обслуживания (например, приоритет) |
| Total Length | 16 | Общая длина IP-пакета (заголовок + данные) в байтах |
| Identification | 16 | Идентификатор пакета для фрагментации |
| Flags | 3 | Управляющие флаги (например, DF — Don't Fragment, MF — More Fragments) |
| Fragment Offset | 13 | Смещение фрагментации в 8-байтных блоках (используется при фрагментации пакета) |
| Time to Live (TTL) | 8 | Время жизни пакета в маршрутизаторах (предотвращает бесконечное циркулирование) |
| Protocol | 8 | Протокол верхнего уровня, который обрабатывает данные (например, TCP = 6, UDP = 17, ICMP = 1) |
| Header Checksum | 16 | Контрольная сумма заголовка для проверки целостности |
| Source IP Address | 32 | IP-адрес отправителя |
| Destination IP Address | 32 | IP-адрес получателя |
| Options | 0–40 | Дополнительные опции (необязательно) |
| Padding | 0–7 | Заполнение для выравнивания заголовка до 32-битных границ |

### Подробное описание полей

1. **Version (Версия)**: Указывает версию IP-протокола. Для IPv4 всегда равно 4.
2. **IHL (Internet Header Length)**: Определяет длину заголовка IP в 32-битных словах. Минимальное значение — 5 (5 × 4 = 20 байт).
3. **Type of Service (ToS)**: Используется для классификации пакетов и управления качеством обслуживания (QoS). Позволяет указать приоритет трафика, задержку, пропускную способность и надежность.
4. **Total Length (Общая длина)**: Указывает общую длину IP-пакета в байтах, включая заголовок и данные. Максимальное значение — 65535 байт.
5. **Identification (Идентификатор)**: Уникальный идентификатор пакета, используемый для идентификации фрагментов при фрагментации.
6. **Flags (Флаги)**:
    - **Bit 0**: Не используется, всегда 0.
    - **Bit 1 (DF — Don't Fragment)**: Если установлен, пакет не должен быть фрагментирован.
    - **Bit 2 (MF — More Fragments)**: Указывает, что после этого фрагмента будут еще фрагменты.
7. **Fragment Offset (Смещение фрагментации)**: Определяет позицию текущего фрагмента в исходном пакете. Измеряется в 8-байтных блоках.
8. **Time to Live (TTL)**: Ограничивает время жизни пакета в сети. Каждый маршрутизатор, который обрабатывает пакет, уменьшает TTL на 1. Если TTL достигает 0, пакет отбрасывается.
9. **Protocol (Протокол)**: Указывает, какой протокол верхнего уровня должен обработать данные. Например:
    - **1**: ICMP
    - **6**: TCP
    - **17**: UDP
10. **Header Checksum (Контрольная сумма заголовка)**: Позволяет проверить целостность заголовка IP. Вычисляется только для заголовка, не включает данные.
11. **Source IP Address (IP-адрес отправителя)**: Уникальный IP-адрес устройства-отправителя.
12. **Destination IP Address (IP-адрес получателя)**: Уникальный IP-адрес устройства-получателя.
13. **Options (Опции)**: Дополнительные параметры для специальных функций, таких как запись маршрута, защита и т.д.
14. **Padding (Заполнение)**: Используется для выравнивания заголовка до 32-битных границ, если заголовок содержит опции.

### Пример заголовка IPv4

```
plaintext
Copy code
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Version| IHL |Type of Service|          Total Length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Identification        |Flags|      Fragment Offset    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Time to Live |    Protocol   |         Header Checksum       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Source IP Address                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Destination IP Address                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options                    |    Padding    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

```

---

## 2. Заголовок IPv6

**IPv6 (Internet Protocol version 6)** — это новая версия IP-протокола, разработанная для решения проблем с адресацией IPv4 и улучшения некоторых функциональных возможностей. Заголовок IPv6 имеет фиксированную длину в 40 байт и упрощённую структуру по сравнению с IPv4.

### Структура заголовка IPv6

| Поле | Длина (бит) | Описание |
| --- | --- | --- |
| Version | 4 | Версия протокола (для IPv6 значение всегда 6) |
| Traffic Class | 8 | Классификация трафика, аналогично ToS в IPv4 |
| Flow Label | 20 | Метка потока для идентификации и приоритезации трафика |
| Payload Length | 16 | Длина полезной нагрузки (данные) в байтах |
| Next Header | 8 | Тип следующего заголовка (например, TCP = 6, UDP = 17, ICMPv6 = 58) |
| Hop Limit | 8 | Аналогично TTL в IPv4, определяет количество маршрутизаторов, через которые может пройти пакет |
| Source Address | 128 | IP-адрес отправителя |
| Destination Address | 128 | IP-адрес получателя |
| Extension Headers | - | Дополнительные заголовки (опционально) |

### Подробное описание полей

1. **Version (Версия)**: Указывает версию IP-протокола. Для IPv6 всегда равно 6.
2. **Traffic Class (Класс трафика)**: Используется для классификации и приоритезации трафика. Аналогично полю ToS в IPv4.
3. **Flow Label (Метка потока)**: Позволяет обозначить последовательность пакетов, относящихся к одному потоку, для обеспечения качества обслуживания (QoS).
4. **Payload Length (Длина полезной нагрузки)**: Указывает длину данных, следующих за заголовком IPv6, в байтах. Максимальная длина — 65535 байт. Для более длинных пакетов используется Jumbo Payload.
5. **Next Header (Следующий заголовок)**: Указывает тип следующего заголовка после заголовка IPv6. Может указывать на транспортный протокол (TCP, UDP, ICMPv6) или на расширяющий заголовок (например, Routing Header, Fragment Header).
6. **Hop Limit (Ограничение по маршрутам)**: Аналогично TTL в IPv4. Определяет максимальное количество маршрутизаторов, через которые может пройти пакет.
7. **Source Address (IP-адрес отправителя)**: Уникальный IPv6-адрес устройства-отправителя.
8. **Destination Address (IP-адрес получателя)**: Уникальный IPv6-адрес устройства-получателя.
9. **Extension Headers (Расширяющие заголовки)**: Дополнительные заголовки, используемые для расширенных функций, таких как маршрутизация, безопасность и фрагментация. Они могут следовать за основным заголовком IPv6 и другими расширяющими заголовками.

### Пример заголовка IPv6

```
plaintext
Copy code
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Version| Traffic Class |           Flow Label                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Payload Length         |  Next Header  |   Hop Limit      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                                                               |
+                         Source Address                        +
|                                                               |
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                                                               |
+                      Destination Address                      +
|                                                               |
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

```

### Отличия от IPv4

- **Более длинные адреса**: IPv6 использует 128-битные адреса, что значительно расширяет адресное пространство по сравнению с 32-битными адресами IPv4.
- **Упрощённый заголовок**: IPv6 имеет фиксированную длину заголовка и убрал некоторые поля IPv4, такие как флаги и смещение фрагментации.
- **Поддержка расширяющихся заголовков**: Позволяет добавлять функциональность без изменения основного заголовка.
- **Автоконфигурация**: Улучшенные механизмы автоконфигурации адресов.

---

## 3. Заголовок TCP

**TCP (Transmission Control Protocol)** — это протокол транспортного уровня модели OSI, обеспечивающий надёжную, ориентированную на соединение передачу данных между приложениями. TCP гарантирует доставку данных в правильном порядке и без ошибок.

### Структура заголовка TCP

| Поле | Длина (бит) | Описание |
| --- | --- | --- |
| Source Port | 16 | Порт отправителя |
| Destination Port | 16 | Порт получателя |
| Sequence Number | 32 | Номер последовательности первого байта данных в данном сегменте |
| Acknowledgment Number | 32 | Номер следующего ожидаемого байта от получателя (подтверждение) |
| Data Offset | 4 | Длина заголовка TCP в 32-битных словах (минимум 5 слов = 20 байт) |
| Reserved | 3 | Зарезервированные биты, всегда равные 0 |
| Flags | 9 | Управляющие флаги (например, SYN, ACK, FIN, RST) |
| Window Size | 16 | Размер окна (количество байт, которые получатель готов принять) |
| Checksum | 16 | Контрольная сумма для проверки целостности заголовка и данных |
| Urgent Pointer | 16 | Указывает на крайний байт данных с флагом URG, требующий немедленной обработки |
| Options | 0–320 | Дополнительные параметры (опционально) |
| Padding | 0–7 | Заполнение для выравнивания заголовка до 32-битных границ |

### Подробное описание полей

1. **Source Port (Порт отправителя)**: Указывает порт на устройстве-отправителе, с которого инициировано соединение или отправляются данные.
2. **Destination Port (Порт получателя)**: Указывает порт на устройстве-получателе, к которому направлены данные.
3. **Sequence Number (Номер последовательности)**: Указывает порядковый номер первого байта данных в текущем сегменте. Используется для обеспечения правильного порядка данных и обнаружения потерь.
4. **Acknowledgment Number (Номер подтверждения)**: Если флаг ACK установлен, это поле содержит номер следующего ожидаемого байта от получателя. Используется для подтверждения получения данных.
5. **Data Offset (Длина заголовка)**: Определяет, где заканчивается заголовок TCP и начинаются данные. Выражается в 32-битных словах. Минимальное значение — 5 (20 байт).
6. **Reserved (Зарезервированные биты)**: В настоящее время всегда равны 0. Зарезервированы для будущего использования.
7. **Flags (Флаги)**:
    - **NS (Nonce Sum)**: Расширенный флаг, используется для защиты от атак.
    - **CWR (Congestion Window Reduced)**: Указывает, что отправитель получил уведомление о снижении окна перегрузки.
    - **ECE (ECN Echo)**: Отмечает получение уведомления о перегрузке от другого конца соединения.
    - **URG (Urgent)**: Указывает, что поле Urgent Pointer содержит действительное значение.
    - **ACK (Acknowledgment)**: Указывает, что поле Acknowledgment Number содержит действительное значение.
    - **PSH (Push)**: Просит получателя немедленно передать данные приложению.
    - **RST (Reset)**: Сбрасывает соединение.
    - **SYN (Synchronize)**: Используется для установления соединения.
    - **FIN (Finish)**: Указывает завершение передачи данных.
8. **Window Size (Размер окна)**: Указывает количество байт, которые получатель готов принять. Используется для управления потоком данных и предотвращения перегрузки.
9. **Checksum (Контрольная сумма)**: Проверяет целостность заголовка и данных. Обязательное поле, позволяющее обнаруживать ошибки в передаче.
10. **Urgent Pointer (Указатель срочности)**: Если установлен флаг URG, указывает на крайний байт срочных данных.
11. **Options (Опции)**: Дополнительные параметры для расширения функциональности TCP, такие как максимальный размер сегмента (MSS), временная метка (Timestamp), окно масштабирования и др.
12. **Padding (Заполнение)**: Используется для выравнивания заголовка до 32-битных границ, если опции присутствуют.

### Пример заголовка TCP

```
plaintext
Copy code
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Sequence Number                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Acknowledgment Number                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Data |Rese-|U|A|P|R|S|F|                               |
| Offset|rved |R|C|S|S|Y|I|            Window Size        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Checksum            |         Urgent Pointer        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options (optional)                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Padding                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

```

### Основные функции TCP-заголовка

- **Установление соединения**: Использование флагов SYN и ACK для тройного рукопожатия (three-way handshake).
- **Обеспечение надёжности**: Номера последовательности и подтверждения обеспечивают доставку данных без потерь и в правильном порядке.
- **Управление потоком**: Размер окна регулирует количество данных, которые могут быть отправлены без получения подтверждения.
- **Контроль перегрузки**: Флаги CWR и ECE помогают управлять перегрузкой сети.
- **Безопасность**: Некоторые опции обеспечивают дополнительные механизмы безопасности и производительности.

---

## 4. Сравнительный анализ IPv4 и IPv6

| Параметр | IPv4 | IPv6 |
| --- | --- | --- |
| **Длина адреса** | 32 бита (4 байта) | 128 бит (16 байт) |
| **Адресное пространство** | ~4.3 миллиарда адресов | ~3.4×10^38 адресов |
| **Формат адреса** | Десятичные числа, разделённые точками (e.g., 192.168.1.1) | Шестнадцатеричные числа, разделённые двоеточиями (e.g., 2001:0db8:85a3:0000:0000:8a2e:0370:7334) |
| **Заголовок** | Переменная длина (20–60 байт) | Фиксированная длина (40 байт) |
| **Функции фрагментации** | На уровне отправителя и маршрутизаторов | На уровне отправителя (маршрутизаторы не фрагментируют) |
| **Автоконфигурация** | Ограниченная (с DHCP) | Улучшенная (stateless address autoconfiguration) |
| **Безопасность** | Не встроена | Встроенная поддержка IPsec |
| **Дополнительные функции** | Некоторые функции через опции | Расширяемость через расширяющие заголовки |

### Основные отличия

1. **Адресное пространство**: IPv6 значительно расширяет количество возможных адресов, что решает проблему исчерпания адресов IPv4.
2. **Структура заголовка**: IPv6 упрощает заголовок, делая его фиксированной длины и убирая некоторые поля IPv4. Это улучшает производительность маршрутизации.
3. **Автоконфигурация**: IPv6 поддерживает более продвинутые механизмы автоконфигурации, включая stateless address autoconfiguration (SLAAC).
4. **Безопасность**: IPv6 изначально проектировался с учётом встроенной поддержки безопасности через IPsec, хотя в IPv4 IPsec также может использоваться как дополнительный компонент.
5. 
<img width="623" alt="Screenshot 2024-12-02 at 12 09 26" src="https://github.com/user-attachments/assets/edd746ac-4535-4e8b-baee-940a52b50f6d">
<img width="731" alt="Screenshot 2024-12-02 at 12 09 36" src="https://github.com/user-attachments/assets/5141488d-d702-4d63-a759-9a0fc33d6797">

